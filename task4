task3中寻找符合条件的a时间复杂度为O(klogn),其中k为匹配数量，n为中数量
输出部分时间复杂度为o(km+l)，m为匹配到的每个队列的长度,l为40。该方法类似桶排序

当要匹配的a为1000,2000,99000时
另外结合该题题干，b的值为[10,50)的整数，也可采用task3的方法。
1、找到(1000,10), (2000,10), ..., (99000,10) 99个起点
2、然后先输出所有b=10的数并下移指针，再输出所有b=11的数并下移指针，直到输出所有满足条件的数
其中步骤1中的可以再次使用二分法来进行优化，采用分执法：
设vec 为匹配队列 1000,2000,3000, ...,99000
1、则先匹配k0 = vec[vec.size()/2], 找到k0的上下界l0，h0
2、然后可将vec 分为vec1 = {1000, 2000, ..., vec[vec.size()/2-1]}, vec2 = {vec[vec.size()/2+1], ..., 99000}
3、vec1和vec2要匹配的数据量也会减半，如此分隔下去。
该方法时间复杂度是O(klogn-4^k)，
